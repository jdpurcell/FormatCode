// --------------------------------------------------------------------------------
// Copyright (c) J.D. Purcell
//
// Licensed under the MIT License (see LICENSE.txt)
// --------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

namespace FormatCode.Library;

public class CodeFormatter {
	private static readonly string[] _autoGeneratedPreprocessorDirectives = {
		"#region Component Designer generated code",
		"#region Windows Form Designer generated code"
	};
	private static readonly string[] _autoGeneratedComments = {
		"// <auto-generated>"
	};

	public int TabSize { get; set; } = 4;

	public TabStyle TabStyle { get; set; } = TabStyle.Detect;

	public OpenBraceStyle OpenBraceStyle { get; set; } = OpenBraceStyle.Leave;

	public NewLineStyle NewLineStyle { get; set; } = NewLineStyle.Detect;

	public bool RequireNewLineAtEnd { get; set; }

	public bool LeaveTrailingWhitespaceInCode { get; set; }

	public bool LeaveTrailingWhitespaceInComments { get; set; }

	public bool LeaveEmptyLines { get; set; }

	public void Format(string path) {
		const char bomChar = '\uFEFF';
		byte[] codeBytes = File.ReadAllBytes(path);
		Encoding encoding = DetectEncoding(codeBytes) ?? Encoding.Default;
		string codeStrRaw = encoding.GetString(codeBytes);
		if (!AreByteArraysEqual(codeBytes, encoding.GetBytes(codeStrRaw))) {
			throw new Exception("Misdetected character encoding!");
		}
		string code = NormalizeNewLines(codeStrRaw, out string inputNewLine);
		string outputNewLine = NewLineStyle switch {
			NewLineStyle.MatchPlatform => Environment.NewLine,
			NewLineStyle.CRLF => "\r\n",
			NewLineStyle.LF => "\n",
			NewLineStyle.CR => "\r",
			_ => inputNewLine ?? Environment.NewLine
		};
		bool fileEndsWithLineEnd = code.Length >= 1 && code[code.Length - 1] == '\n';
		int i = 0;
		List<Line> lines = new();
		Context currentContext = new NormalContext();
		Stack<Context> contexts = new(new[] { currentContext });

		char Peek(int offset) {
			const int maxSpill = 1024;
			int index = i + offset;
			if (index >= 0 && index < code.Length) {
				return code[index];
			}
			if (index >= -maxSpill && index < code.Length + maxSpill) {
				return '\n';
			}
			throw new Exception("Detected unterminated sequence.");
		}
		IEnumerable<char> PeekWhile(Predicate<char> predicate, bool reverse = false) {
			int offset = 0;
			int step = reverse ? -1 : 1;
			while (true) {
				char c = Peek(offset);
				if (!predicate(c)) yield break;
				yield return c;
				offset += step;
			}
		}
		bool CodeStartsWithAnyIgnoreCase(string[] values) => values.Any(v => String.Compare(code, i, v, 0, v.Length, StringComparison.OrdinalIgnoreCase) == 0);

		void PushContext(Context context) {
			currentContext = context;
			contexts.Push(context);
		}
		void PopContext() {
			contexts.Pop();
			currentContext = contexts.Peek();
		}
		Context PreviousContext() => contexts.ElementAtOrDefault(1);

		bool hasBOM = Peek(0) == bomChar;
		if (hasBOM) {
			i++;
		}

		while (i < code.Length) {
			Line line = new(this);

			while (Peek(0) == ' ' || Peek(0) == '\t') {
				bool isTab = Peek(0) == '\t';
				line.IndentationSize += isTab ? (TabSize - (line.IndentationSize % 4)) : 1;
				line.IndentationContainsTabs |= isTab;
				i++;
			}

			int lineSubstanceStart = i;

			char firstChar;
			while ((firstChar = Peek(0)) != '\n' || currentContext is not NormalContext) {
				// Verbatim interpolated string
				if (currentContext is VerbatimInterpolatedStringContext ||
					(currentContext is NormalContext &&
					 ((firstChar == '$' && Peek(1) == '@' && Peek(2) == '"') ||
					  (firstChar == '@' && Peek(1) == '$' && Peek(2) == '"'))))
				{
					if (currentContext is NormalContext) {
						i += 3;
						PushContext(new VerbatimInterpolatedStringContext());
					}
					bool IsEndQuote() => Peek(0) == '"' && Peek(1) != '"';
					bool IsCodeSection() => Peek(0) == '{' && Peek(1) != '{';
					while (!IsEndQuote() && !IsCodeSection()) i += Peek(0) == '"' || Peek(0) == '{' ? 2 : 1;
					if (IsCodeSection()) {
						PushContext(new NormalContext());
					}
					else if (IsEndQuote()) {
						PopContext();
					}
					else throw new InvalidOperationException();
					i++;
				}
				// Raw interpolated string
				else if (currentContext is RawInterpolatedStringContext ||
					(currentContext is NormalContext &&
					 firstChar == '$' && Peek(1) == '"' && Peek(2) == '"' && Peek(3) == '"'))
				{
					if (currentContext is NormalContext) {
						int numberOfDollarSigns = PeekWhile(c => c == '$', reverse: true).Count();
						i++;
						int numberOfStartQuotes = PeekWhile(c => c == '"').Count();
						i += numberOfStartQuotes;
						PushContext(new RawInterpolatedStringContext(numberOfDollarSigns, numberOfStartQuotes));
					}
					RawInterpolatedStringContext risContext = (RawInterpolatedStringContext)currentContext;
					bool foundStringEnd = false;
					bool foundCodeSection = false;
					do {
						if (Peek(0) == '"') {
							int charCount = PeekWhile(c => c == '"').Count();
							if (charCount > risContext.NumberOfStartQuotes)
								throw new Exception("Detected raw string literal quotes mismatch.");
							foundStringEnd = charCount == risContext.NumberOfStartQuotes;
							i += charCount;
						}
						else if (Peek(0) == '{') {
							int charCount = PeekWhile(c => c == '{').Count();
							if (charCount >= risContext.NumberOfDollarSigns * 2)
								throw new Exception("Detected raw string literal interpolation brace excess.");
							foundCodeSection = charCount >= risContext.NumberOfDollarSigns;
							i += charCount;
						}
						else i++;
					}
					while (!foundStringEnd && !foundCodeSection);
					if (foundCodeSection) {
						PushContext(new NormalContext());
					}
					else if (foundStringEnd) {
						PopContext();
					}
					else throw new InvalidOperationException();
				}
				// Interpolated string
				else if (currentContext is PlainInterpolatedStringContext ||
					(currentContext is NormalContext &&
					 firstChar == '$' && Peek(1) == '"'))
				{
					if (currentContext is NormalContext) {
						i += 2;
						PushContext(new PlainInterpolatedStringContext());
					}
					bool IsEndQuote() => Peek(0) == '"';
					bool IsCodeSection() => Peek(0) == '{' && Peek(1) != '{';
					while (!IsEndQuote() && !IsCodeSection()) i += Peek(0) == '\\' || Peek(0) == '{' ? 2 : 1;
					if (IsCodeSection()) {
						PushContext(new NormalContext());
					}
					else if (IsEndQuote()) {
						PopContext();
					}
					else throw new InvalidOperationException();
					i++;
				}
				// Preprocessor directive
				else if (firstChar == '#' && i == lineSubstanceStart && contexts.Count == 1) {
					if (CodeStartsWithAnyIgnoreCase(_autoGeneratedPreprocessorDirectives)) return;
					i++;
					while (Peek(0) != '\n') i++;
					line.IsPreprocessorDirective = true;
				}
				// Single line comment
				else if (firstChar == '/' && Peek(1) == '/') {
					if (CodeStartsWithAnyIgnoreCase(_autoGeneratedComments)) return;
					line.EndsWithXmlDocComment = Peek(2) == '/' && Peek(3) != '/';
					line.EndsWithSingleLineComment = !line.EndsWithXmlDocComment;
					i += line.EndsWithXmlDocComment ? 3 : 2;
					while (Peek(0) != '\n') i++;
				}
				// Multi line comment
				else if (firstChar == '/' && Peek(1) == '*') {
					i += 2;
					while (!(Peek(0) == '*' && Peek(1) == '/')) i++;
					i += 2;
					line.EndsWithMultiLineComment = PeekWhile(c => c != '\n').Any(c => c != '\t' && c != ' ');
				}
				// Verbatim string literal
				else if (firstChar == '@' && Peek(1) == '"') {
					i += 2;
					while (!(Peek(0) == '"' && Peek(1) != '"')) i += Peek(0) == '"' ? 2 : 1;
					i++;
				}
				// Raw string literal
				else if (firstChar == '"' && Peek(1) == '"' && Peek(2) == '"') {
					int numberOfStartQuotes = PeekWhile(c => c == '"').Count();
					i+= numberOfStartQuotes;
					bool foundStringEnd = false;
					do {
						if (Peek(0) == '"') {
							int charCount = PeekWhile(c => c == '"').Count();
							if (charCount > numberOfStartQuotes)
								throw new Exception("Detected raw string literal quotes mismatch.");
							foundStringEnd = charCount == numberOfStartQuotes;
							i += charCount;
						}
						else i++;
					}
					while (!foundStringEnd);
				}
				// String literal
				else if (firstChar == '"') {
					i++;
					while (Peek(0) != '"') i += Peek(0) == '\\' ? 2 : 1;
					i++;
				}
				// Character literal
				else if (firstChar == '\'') {
					i++;
					while (Peek(0) != '\'') i += Peek(0) == '\\' ? 2 : 1;
					i++;
				}
				// Open brace. We only need to track these if we're in the code block of an interpolated
				// string. Then when we see a close brace, we can tell if it corresponds to a prior open
				// brace within the code block, or the initial one that began the code block. Or when we
				// see a colon we can tell if it was something like a conditional expression inside a
				// braced lambda body, or whether it begins the format string.
				else if (firstChar == '{' && contexts.Count > 1) {
					i++;
					currentContext.BraceDepth++;
				}
				// Close brace
				else if (firstChar == '}' && contexts.Count > 1) {
					currentContext.BraceDepth--;
					if (currentContext.BraceDepth == -1 && PreviousContext() is IInterpolatedStringContext) {
						if (currentContext.ParenDepth != 0)
							throw new Exception("Detected mismatched parentheses.");
						if (currentContext.BracketDepth != 0)
							throw new Exception("Detected mismatched brackets.");
						PopContext();
						if (currentContext is RawInterpolatedStringContext risContext) {
							int charCount = PeekWhile(c => c == '}').Count();
							if (charCount >= risContext.NumberOfDollarSigns * 2)
								throw new Exception("Detected raw string literal interpolation brace excess.");
							if (charCount < risContext.NumberOfDollarSigns)
								throw new Exception("Detected raw string literal interpolation brace deficit.");
							i += charCount;
						}
						else i++;
					}
					else i++;
				}
				// Open parenthesis. Like braces, these must be tracked sometimes to determine context.
				// Example in which the colon does not begin a format string:
				// string s = $"{(true ? 1 : 2)}";
				else if (firstChar == '(' && contexts.Count > 1) {
					i++;
					currentContext.ParenDepth++;
				}
				// Close parenthesis
				else if (firstChar == ')' && contexts.Count > 1) {
					i++;
					if (--currentContext.ParenDepth == -1)
						throw new Exception("Detected mismatched parentheses.");
				}
				// Open bracket. Like braces, these must be tracked sometimes to determine context.
				// Example in which the colon does not begin a format string:
				// string s = $"{"abc"[true ? 1 : 2]}";
				else if (firstChar == '[' && contexts.Count > 1) {
					i++;
					currentContext.BracketDepth++;
				}
				// Close bracket
				else if (firstChar == ']' && contexts.Count > 1) {
					i++;
					if (--currentContext.BracketDepth == -1)
						throw new Exception("Detected mismatched brackets.");
				}
				// Format section of interpolated string
				else if (firstChar == ':' &&
					currentContext.BraceDepth == 0 &&
					currentContext.ParenDepth == 0 &&
					currentContext.BracketDepth == 0 &&
					PreviousContext() is IInterpolatedStringContext)
				{
					i++;
					PopContext();
					while (Peek(0) != '}') i++;
					if (currentContext is RawInterpolatedStringContext risContext) {
						int charCount = PeekWhile(c => c == '}').Count();
						if (charCount >= risContext.NumberOfDollarSigns * 2)
							throw new Exception("Detected raw string literal interpolation brace excess.");
						if (charCount < risContext.NumberOfDollarSigns)
							throw new Exception("Detected raw string literal interpolation brace deficit.");
						i += charCount;
					}
					else i++;
				}
				// Anything else
				else {
					i++;
				}
			}

			line.SetSubstanceRaw(code.Substring(lineSubstanceStart, i - lineSubstanceStart));
			lines.Add(line);
			i++;
		}

		if (contexts.Count != 1) {
			throw new Exception("Detected incomplete interpolated string.");
		}

		ProcessLines(lines);

		StringBuilder newCodeSB = new(codeStrRaw.Length);
		IEnumerable<Line> indentedLines = lines.Where(l => l.IndentationSize != 0);
		bool tabsAsSpaces = TabStyle == TabStyle.Spaces ||
			(TabStyle == TabStyle.Detect && indentedLines.Count(l => !l.IndentationContainsTabs) > indentedLines.Count(l => l.IndentationContainsTabs));
		void AppendIndentation(int size) {
			if (tabsAsSpaces) {
				newCodeSB.Append(' ', size);
			}
			else {
				newCodeSB.Append('\t', size / 4);
				newCodeSB.Append(' ',  size % 4);
			}
		}
		if (hasBOM) {
			newCodeSB.Append(bomChar);
		}
		for (int iLine = 0; iLine < lines.Count; iLine++) {
			if (iLine != 0) newCodeSB.Append(outputNewLine);
			AppendIndentation(lines[iLine].OutputIndentationSize);
			foreach (char c in lines[iLine].OutputSubstance) {
				if (c != '\n')
					newCodeSB.Append(c);
				else
					newCodeSB.Append(outputNewLine);
			}
		}
		if (RequireNewLineAtEnd || fileEndsWithLineEnd) {
			newCodeSB.Append(outputNewLine);
		}
		string newCode = newCodeSB.ToString();
		if (!StringEqualsIgnoreWhitespace(code, newCode)) {
			throw new Exception("Code contents changed!");
		}
		byte[] newCodeBytes = encoding.GetBytes(newCode);
		if (!AreByteArraysEqual(codeBytes, newCodeBytes)) {
			File.WriteAllBytes(path, newCodeBytes);
		}
	}

	private void ProcessLines(List<Line> lines) {
		int iLine = 0;
		bool shouldRemoveCurrentLine;

		Line PeekLine(int offset) {
			int idx = iLine + offset;
			return idx >= 0 && idx < lines.Count ? lines[idx] : null;
		}
		void FlagCurrentLineForRemoval() {
			shouldRemoveCurrentLine = true;
		}
		void InsertLineAfterCurrent(Line line) {
			lines.Insert(iLine + 1, line);
		}

		while (iLine < lines.Count) {
			shouldRemoveCurrentLine = false;
			ProcessLine(lines[iLine], PeekLine, FlagCurrentLineForRemoval, InsertLineAfterCurrent);
			if (shouldRemoveCurrentLine) {
				lines.RemoveAt(iLine);
			}
			else {
				iLine++;
			}
		}
	}

	private void ProcessLine(Line line, Func<int, Line> peekLine, Action flagCurrentLineForRemoval, Action<Line> insertLineAfterCurrent) {
		Line prevLine = peekLine(-1);
		Line nextLine = peekLine(1);

		int nextLineOffset = 1;
		void GetNextLine() { nextLine = peekLine(++nextLineOffset); }

		if (!LeaveEmptyLines && line.IsEmpty) {
			while (nextLine != null && nextLine.IsEmpty) {
				GetNextLine();
			}
			bool isDuplicate = prevLine?.IsEmpty ?? false;
			bool isAfterXmlDocComment = prevLine?.EndsWithXmlDocComment ?? false;
			bool isAfterOpenBrace = prevLine?.CodeEndsWith('{') ?? false;
			bool isBeforeCloseBrace = nextLine?.CodeStartsWith('}') ?? false;
			bool isLastLine = nextLine == null;
			if (isAfterOpenBrace && isBeforeCloseBrace) {
				// An empty line is okay here
			}
			else if (isDuplicate || isAfterXmlDocComment || isAfterOpenBrace || isBeforeCloseBrace || isLastLine) {
				flagCurrentLineForRemoval();
			}
		}
		else if (OpenBraceStyle == OpenBraceStyle.MoveUp && line.Substance == "{" && prevLine != null && line.IndentationSize == prevLine.IndentationSize &&
			!prevLine.IsEmpty && !prevLine.EndsWithComment && !prevLine.IsPreprocessorDirective && !prevLine.CodeEndsWith('}') &&
			!prevLine.CodeEndsWith(';') && !prevLine.CodeEndsWith(','))
		{
			prevLine.SetSubstanceRaw(prevLine.SubstanceRaw + " {");
			flagCurrentLineForRemoval();
		}
		else if (OpenBraceStyle == OpenBraceStyle.MoveDown && line.Substance.Length > 1 && line.CodeEndsWith('{')) {
			while (nextLine != null && (nextLine.IsEmpty || nextLine.IsPreprocessorDirective)) {
				GetNextLine();
			}
			if (nextLine != null) {
				line.SetSubstanceRaw(line.Substance.Substring(0, line.Substance.Length - 1).TrimEnd(' ', '\t'));

				bool matchIndentation = nextLine.CodeStartsWith('}') || StartsWithLabel(nextLine.Substance);
				Line insertLine = new(this);
				insertLine.IndentationSize = Math.Max(matchIndentation ? nextLine.IndentationSize : nextLine.IndentationSize - TabSize, line.IndentationSize);
				insertLine.IndentationContainsTabs = nextLine.IndentationContainsTabs;
				insertLine.SetSubstanceRaw("{");
				insertLineAfterCurrent(insertLine);
			}
		}
	}

	private static bool AreByteArraysEqual(byte[] a, byte[] b) {
		if (a.Length != b.Length) return false;
		for (int i = 0; i < a.Length; i++) {
			if (a[i] != b[i]) return false;
		}
		return true;
	}

	private static bool StringEqualsIgnoreWhitespace(string strA, string strB) {
		int iA = 0;
		int iB = 0;

		static bool IsWhitespace(char c) => c == ' ' || c == '\t' || c == '\r' || c == '\n';

		while (iA < strA.Length && IsWhitespace(strA[iA])) iA++;
		while (iB < strB.Length && IsWhitespace(strB[iB])) iB++;

		while (iA < strA.Length && iB < strB.Length) {
			if (strA[iA++] != strB[iB++]) return false;

			while (iA < strA.Length && IsWhitespace(strA[iA])) iA++;
			while (iB < strB.Length && IsWhitespace(strB[iB])) iB++;
		}

		return iA == strA.Length && iB == strB.Length;
	}

	private static Encoding DetectEncoding(byte[] bytes) {
		BOMType bomType = GetBOMType(bytes);
		if (bomType == BOMType.UTF8)
			return new UTF8Encoding(true);
		if (bomType == BOMType.UTF16LE)
			return new UnicodeEncoding(false, true);
		if (bomType == BOMType.UTF16BE)
			return new UnicodeEncoding(true, true);
		if (IsStronglyUTF8(bytes))
			return new UTF8Encoding(false);
		return null;
	}

	private static BOMType GetBOMType(byte[] bytes) {
		if (bytes.Length >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) return BOMType.UTF8;
		if (bytes.Length >= 2 && bytes[0] == 0xFF && bytes[1] == 0xFE) return BOMType.UTF16LE;
		if (bytes.Length >= 2 && bytes[0] == 0xFE && bytes[1] == 0xFF) return BOMType.UTF16BE;
		return BOMType.None;
	}

	private static bool IsStronglyUTF8(byte[] bytes) {
		bool sawUTF8Sequence = false;
		int i = 0;
		while (i < bytes.Length) {
			if (bytes[i] <= 0x7F)
			{ i++; continue; }
			int extra = bytes.Length - i - 1;
			bool IsContinuation(int offset) => (bytes[i + offset] & 0b11000000) == 0b10000000;
			if ((bytes[i] & 0b11100000) == 0b11000000 && extra >= 1 && IsContinuation(1) &&
				(bytes[i] & 0b00011110) != 0)
			{ i += 2; sawUTF8Sequence = true; continue; }
			if ((bytes[i] & 0b11110000) == 0b11100000 && extra >= 2 && IsContinuation(1) && IsContinuation(2) &&
				(bytes[i] & 0b00001111 | bytes[i + 1] & 0b00100000) != 0)
			{ i += 3; sawUTF8Sequence = true; continue; }
			if ((bytes[i] & 0b11111000) == 0b11110000 && extra >= 3 && IsContinuation(1) && IsContinuation(2) && IsContinuation(3) &&
				(bytes[i] & 0b00000111 | bytes[i + 1] & 0b00110000) != 0)
			{ i += 4; sawUTF8Sequence = true; continue; }
			return false;
		}
		return sawUTF8Sequence;
	}

	private static string NormalizeNewLines(string src, out string detectedNewLine) {
		char[] dst = new char[src.Length];
		int iDst = 0;
		int crlfCount = 0;
		int lfCount = 0;
		int crCount = 0;
		for (int iSrc = 0; iSrc < src.Length; iSrc++) {
			if (src[iSrc] == '\r') {
				if (iSrc < src.Length - 1 && src[iSrc + 1] == '\n') {
					crlfCount++;
					iSrc++;
				}
				else {
					crCount++;
				}
				dst[iDst++] = '\n';
			}
			else if (src[iSrc] == '\n') {
				lfCount++;
				dst[iDst++] = '\n';
			}
			else {
				dst[iDst++] = src[iSrc];
			}
		}
		var stats = new[] {
			new { Type = "\r\n", Count = crlfCount },
			new { Type = "\n", Count = lfCount },
			new { Type = "\r", Count = crCount }
		};
		detectedNewLine =
			(from s in stats
			 where s.Count != 0
			 orderby s.Count descending
			 select s.Type).FirstOrDefault();
		return new string(dst, 0, iDst);
	}

	private static bool StartsWithLabel(string s) {
		int p = s.IndexOf(':');
		return p != -1 && IsIdentifier(s.Substring(0, p));
	}

	private static bool IsIdentifier(string s) {
		static bool IsStartCategory(UnicodeCategory uc) =>
			uc == UnicodeCategory.UppercaseLetter || uc == UnicodeCategory.LowercaseLetter || uc == UnicodeCategory.TitlecaseLetter ||
			uc == UnicodeCategory.ModifierLetter || uc == UnicodeCategory.OtherLetter || uc == UnicodeCategory.LetterNumber;

		static bool IsPartCategory(UnicodeCategory uc) =>
			IsStartCategory(uc) || uc == UnicodeCategory.NonSpacingMark || uc == UnicodeCategory.SpacingCombiningMark ||
			uc == UnicodeCategory.DecimalDigitNumber || uc == UnicodeCategory.ConnectorPunctuation || uc == UnicodeCategory.Format;

		static bool IsStartCharacter(char c) => c == '_' || IsStartCategory(Char.GetUnicodeCategory(c));

		static bool IsPartCharacter(char c) => IsPartCategory(Char.GetUnicodeCategory(c));

		int i = 0;
		if (s.Length >= 1 && s[0] == '@') i++;
		if (i == s.Length) return false;
		if (!IsStartCharacter(s[i])) return false;
		i++;
		while (i < s.Length) {
			if (!IsPartCharacter(s[i])) return false;
			i++;
		}
		return true;
	}

	private class Line {
		private CodeFormatter Owner { get; }

		public Line(CodeFormatter owner) {
			Owner = owner;
		}

		public int IndentationSize { get; set; }
		public bool IndentationContainsTabs { get; set; }
		public bool EndsWithSingleLineComment { get; set; }
		public bool EndsWithXmlDocComment { get; set; }
		public bool EndsWithMultiLineComment { get; set; }
		public bool IsPreprocessorDirective { get; set; }
		public string Substance { get; private set; }
		public string SubstanceRaw { get; private set; }

		public void SetSubstanceRaw(string value) {
			SubstanceRaw = value;
			Substance = value.TrimEnd(' ', '\t');
		}

		public bool CodeStartsWith(char c) =>
			Substance.Length >= 1 &&
			Substance[0] == c;

		public bool CodeEndsWith(char c) =>
			!EndsWithComment &&
			!IsPreprocessorDirective &&
			Substance.Length >= 1 &&
			Substance[Substance.Length - 1] == c;

		public bool IsEmpty => Substance.Length == 0;

		public bool EndsWithComment =>
			EndsWithSingleLineComment ||
			EndsWithXmlDocComment ||
			EndsWithMultiLineComment;

		public string OutputSubstance => !LeaveTrailingWhitespace ? Substance : SubstanceRaw;

		public int OutputIndentationSize => !LeaveTrailingWhitespace && IsEmpty ? 0 : IndentationSize;

		private bool LeaveTrailingWhitespace =>
			EndsWithSingleLineComment || EndsWithXmlDocComment ? Owner.LeaveTrailingWhitespaceInComments : Owner.LeaveTrailingWhitespaceInCode;
	}

	private abstract class Context {
		public int BraceDepth { get; set; }
		public int ParenDepth { get; set; }
		public int BracketDepth { get; set; }
	}

	private class NormalContext : Context { }

	private class PlainInterpolatedStringContext : Context, IInterpolatedStringContext { }

	private class VerbatimInterpolatedStringContext : Context, IInterpolatedStringContext { }

	private class RawInterpolatedStringContext : Context, IInterpolatedStringContext {
		public int NumberOfDollarSigns { get; }
		public int NumberOfStartQuotes { get; }

		public RawInterpolatedStringContext(int numberOfDollarSigns, int numberOfStartQuotes) {
			NumberOfDollarSigns = numberOfDollarSigns;
			NumberOfStartQuotes = numberOfStartQuotes;
		}
	}

	private interface IInterpolatedStringContext { }

	private enum BOMType {
		None,
		UTF8,
		UTF16LE,
		UTF16BE
	}
}

public enum TabStyle {
	Detect,
	Tabs,
	Spaces
}

public enum OpenBraceStyle {
	Leave,
	MoveUp,
	MoveDown
}

public enum NewLineStyle {
	Detect,
	MatchPlatform,
	CRLF,
	LF,
	CR
}
