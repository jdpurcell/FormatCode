// --------------------------------------------------------------------------------
// Copyright (c) J.D. Purcell
//
// Licensed under the MIT License (see LICENSE.txt)
// --------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace FormatCode {
	public class CodeFormatter {
		public int TabSize { get; set; } = 4;

		public bool TabsAsSpaces { get; set; }

		public bool MoveOpenBracesUp { get; set; }

		public bool RequireNewLineAtEnd { get; set; }

		public void Format(string path) {
			const char bomChar = '\uFEFF';
			byte[] codeBytes = File.ReadAllBytes(path);
			Encoding encoding = DetectEncoding(codeBytes) ?? Encoding.Default;
			string codeStrRaw = encoding.GetString(codeBytes);
			if (!AreByteArraysEqual(codeBytes, encoding.GetBytes(codeStrRaw))) {
				throw new Exception("Misdetected character encoding!");
			}
			string code = new StringBuilder(codeStrRaw).Replace("\r\n", "\n").Replace("\r", "\n").ToString();
			bool fileEndsWithLineEnd = code.Length >= 1 && code[code.Length - 1] == '\n';
			int i = 0;
			List<string> lines = new List<string>();
			LineInfo prevLineInfo = null;
			Stack<Context> contexts = new Stack<Context>(new[] { new NormalContext() });
			bool isInInterpolatedStringFormatSection = false;

			if (code.IndexOf("#region Component Designer generated code", StringComparison.OrdinalIgnoreCase) != -1 ||
				code.IndexOf("#region Windows Form Designer generated code", StringComparison.OrdinalIgnoreCase) != -1 ||
				code.IndexOf("// <auto-generated>", StringComparison.OrdinalIgnoreCase) != -1)
			{
				return;
			}

			char peek(int offset) {
				const int maxSpill = 1024;
				int index = i + offset;
				if (index >= 0 && index < code.Length) {
					return code[index];
				}
				if (index >= -maxSpill && index < code.Length + maxSpill) {
					return '\n';
				}
				throw new Exception("Detected unterminated sequence.");
			}
			Context context(int depth = 0) => depth < contexts.Count ? contexts.ElementAt(depth) : null;

			bool hasBOM = peek(0) == bomChar;
			if (hasBOM) {
				i++;
			}

			while (i < code.Length) {
				LineInfo lineInfo = new LineInfo();

				while (peek(0) == ' ' || peek(0) == '\t') {
					lineInfo.LeadingWhitespaceCount += peek(0) == '\t' ? (TabSize - (lineInfo.LeadingWhitespaceCount % 4)) : 1;
					i++;
				}

				int lineSubstanceStart = i;

				while (peek(0) != '\n' || !(context() is NormalContext)) {
					if (context() is VerbatimInterpolatedStringContext || (peek(0) == '$' && peek(1) == '@' && peek(2) == '"')) { // Verbatim interpolated string
						if (isInInterpolatedStringFormatSection) {
							while (!(peek(0) == '}' && peek(1) != '}')) i += peek(0) == '}' ? 2 : 1;
							i++;
							isInInterpolatedStringFormatSection = false;
						}
						else {
							if (context() is NormalContext) {
								contexts.Push(new VerbatimInterpolatedStringContext());
								i += 3;
							}
							bool IsEndQuote() => peek(0) == '"' && peek(1) != '"';
							bool IsCodeSection() => peek(0) == '{' && peek(1) != '{';
							while (!IsEndQuote() && !IsCodeSection()) i += peek(0) == '"' || peek(0) == '{' ? 2 : 1;
							if (IsCodeSection()) {
								contexts.Push(new NormalContext());
							}
							else if (IsEndQuote()) {
								contexts.Pop();
							}
							i++;
						}
					}
					else if (context() is InterpolatedStringContext || (peek(0) == '$' && peek(1) == '"')) { // Interpolated string
						if (isInInterpolatedStringFormatSection) {
							while (!(peek(0) == '}' && peek(1) != '}')) i += peek(0) == '}' ? 2 : 1;
							i++;
							isInInterpolatedStringFormatSection = false;
						}
						else {
							if (context() is NormalContext) {
								contexts.Push(new InterpolatedStringContext());
								i += 2;
							}
							bool IsEndQuote() => peek(0) == '"';
							bool IsCodeSection() => peek(0) == '{' && peek(1) != '{';
							while (!IsEndQuote() && !IsCodeSection()) i += peek(0) == '\\' || peek(0) == '{' ? 2 : 1;
							if (IsCodeSection()) {
								contexts.Push(new NormalContext());
							}
							else if (IsEndQuote()) {
								contexts.Pop();
							}
							i++;
						}
					}
					else if (i == lineSubstanceStart && peek(0) == '#' && contexts.Count == 1) { // Preprocessor directive
						i++;
						while (peek(0) != '\n') i++;
						lineInfo.IsPreprocessorDirective = true;
					}
					else if (peek(0) == '/' && peek(1) == '/') { // Single line comment
						lineInfo.EndsWithXmlDocComment = peek(2) == '/' && peek(3) != '/';
						i += lineInfo.EndsWithXmlDocComment ? 3 : 2;
						while (peek(0) != '\n') i++;
						lineInfo.EndsWithComment = true;
					}
					else if (peek(0) == '/' && peek(1) == '*') { // Multi line comment
						i += 2;
						while (!(peek(0) == '*' && peek(1) == '/')) i++;
						i += 2;
						lineInfo.EndsWithComment = Enumerable.Range(0, Int32.MaxValue).Select(n => peek(n)).TakeWhile(c => c != '\n').Any(c => c != '\t' && c != ' ');
					}
					else if (peek(0) == '@' && peek(1) == '"') { // Verbatim string literal
						i += 2;
						while (!(peek(0) == '"' && peek(1) != '"')) i += peek(0) == '"' ? 2 : 1;
						i++;
					}
					else if (peek(0) == '"') { // String literal
						i++;
						while (peek(0) != '"') i += peek(0) == '\\' ? 2 : 1;
						i++;
					}
					else if (peek(0) == '\'') { // Character literal
						i++;
						while (peek(0) != '\'') i += peek(0) == '\\' ? 2 : 1;
						i++;
					}
					else if (peek(0) == '{' && contexts.Count > 1) {
						i++;
						context().BlockDepth++;
					}
					else if (peek(0) == '}' && contexts.Count > 1) {
						i++;
						if (--context().BlockDepth == -1) {
							if (context().ParenDepth != 0) {
								throw new Exception("Detected parentheses mismatch.");
							}
							contexts.Pop();
						}
					}
					else if (peek(0) == '(' && contexts.Count > 1) {
						i++;
						context().ParenDepth++;
					}
					else if (peek(0) == ')' && contexts.Count > 1) {
						i++;
						if (--context().ParenDepth == -1) {
							throw new Exception("Detected parentheses mismatch.");
						}
					}
					else if (peek(0) == ':' && context().ParenDepth == 0 && (context(1) is InterpolatedStringContext || context(1) is VerbatimInterpolatedStringContext)) {
						i++;
						contexts.Pop();
						isInInterpolatedStringFormatSection = true;
					}
					else {
						i++;
					}
				}

				if (contexts.Count > 1 && contexts.OfType<InterpolatedStringContext>().Any()) {
					throw new Exception("Detected incomplete interpolated string.");
				}

				string lineSubstance = code.Substring(lineSubstanceStart, i - lineSubstanceStart).TrimEnd(' ', '\t');
				lineInfo.EndsWithOpenBrace = !lineInfo.EndsWithComment && !lineInfo.IsPreprocessorDirective && lineSubstance.EndsWith("{");
				lineInfo.EndsWithCloseBrace = !lineInfo.EndsWithComment && !lineInfo.IsPreprocessorDirective && lineSubstance.EndsWith("}");
				lineInfo.EndsWithSemicolon = !lineInfo.EndsWithComment && !lineInfo.IsPreprocessorDirective && lineSubstance.EndsWith(";");
				lineInfo.EndsWithComma = !lineInfo.EndsWithComment && !lineInfo.IsPreprocessorDirective && lineSubstance.EndsWith(",");
				lineInfo.IsEmpty = lineSubstance.Length == 0;
				lineInfo.IsEmptyAfterEndingWithOpenBrace = prevLineInfo != null && lineInfo.IsEmpty && prevLineInfo.EndsWithOpenBrace;
				bool skippedLine = false;
				string MakeIndentation(int count) => TabsAsSpaces ? new string(' ', count) : new string('\t', count / 4) + new string(' ', count % 4);
				string line = lineInfo.IsEmpty ? "" : MakeIndentation(lineInfo.LeadingWhitespaceCount) + lineSubstance;

				if (MoveOpenBracesUp && prevLineInfo != null && lineSubstance == "{" && lineInfo.LeadingWhitespaceCount == prevLineInfo.LeadingWhitespaceCount &&
					!prevLineInfo.IsEmpty && !prevLineInfo.EndsWithComment && !prevLineInfo.IsPreprocessorDirective && !prevLineInfo.EndsWithCloseBrace &&
					!prevLineInfo.EndsWithSemicolon && !prevLineInfo.EndsWithComma)
				{
					lines[lines.Count - 1] += " {";
				}
				else if (prevLineInfo != null && lineInfo.IsEmpty && prevLineInfo.IsEmpty) {
					skippedLine = true;
				}
				else if (prevLineInfo != null && lineInfo.IsEmpty && prevLineInfo.EndsWithXmlDocComment) {
					skippedLine = true;
				}
				else if (prevLineInfo != null && !lineSubstance.StartsWith("}") && prevLineInfo.IsEmptyAfterEndingWithOpenBrace) {
					lines[lines.Count - 1] = line;
				}
				else if (prevLineInfo != null && lineSubstance.StartsWith("}") && prevLineInfo.IsEmpty && !prevLineInfo.IsEmptyAfterEndingWithOpenBrace) {
					lines[lines.Count - 1] = line;
				}
				else {
					lines.Add(line);
				}

				i++;
				if (!skippedLine) {
					prevLineInfo = lineInfo;
				}
			}

			if (contexts.Count != 1) {
				throw new Exception("Detected incomplete verbatim interpolated string.");
			}

			if (lines.Count != 0 && lines[lines.Count - 1].Length == 0) {
				lines.RemoveAt(lines.Count - 1);
			}

			StringBuilder newCodeSB = new StringBuilder();
			if (hasBOM) {
				newCodeSB.Append(bomChar);
			}
			newCodeSB.Append(String.Join("\n", lines));
			if (RequireNewLineAtEnd || fileEndsWithLineEnd) {
				newCodeSB.Append("\n");
			}
			newCodeSB = newCodeSB.Replace("\n", Environment.NewLine);
			string newCode = newCodeSB.ToString();
			if (!StringEqualsIgnoreWhitespace(code, newCode)) {
				throw new Exception("Code contents changed!");
			}
			byte[] newCodeBytes = encoding.GetBytes(newCode);
			if (!AreByteArraysEqual(codeBytes, newCodeBytes)) {
				File.WriteAllBytes(path, newCodeBytes);
			}
		}

		private static bool AreByteArraysEqual(byte[] a, byte[] b) {
			if (a.Length != b.Length) return false;
			for (int i = 0; i < a.Length; i++) {
				if (a[i] != b[i]) return false;
			}
			return true;
		}

		private static bool StringEqualsIgnoreWhitespace(string strA, string strB) {
			int iA = 0;
			int iB = 0;

			while (iA < strA.Length && Char.IsWhiteSpace(strA, iA)) iA++;
			while (iB < strB.Length && Char.IsWhiteSpace(strB, iB)) iB++;

			while (iA < strA.Length && iB < strB.Length) {
				if (strA[iA++] != strB[iB++]) return false;

				while (iA < strA.Length && Char.IsWhiteSpace(strA, iA)) iA++;
				while (iB < strB.Length && Char.IsWhiteSpace(strB, iB)) iB++;
			}

			return iA == strA.Length && iB == strB.Length;
		}

		private static Encoding DetectEncoding(byte[] bytes) {
			BOMType bomType = GetBOMType(bytes);
			if (bomType == BOMType.UTF8)
				return new UTF8Encoding(true);
			if (bomType == BOMType.UTF16LE)
				return new UnicodeEncoding(false, true);
			if (bomType == BOMType.UTF16BE)
				return new UnicodeEncoding(true, true);
			if (HasUTF8Sequence(bytes))
				return new UTF8Encoding(false);
			return null;
		}

		private static BOMType GetBOMType(byte[] bytes) {
			if (bytes.Length >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) return BOMType.UTF8;
			if (bytes.Length >= 2 && bytes[0] == 0xFF && bytes[1] == 0xFE) return BOMType.UTF16LE;
			if (bytes.Length >= 2 && bytes[0] == 0xFE && bytes[1] == 0xFF) return BOMType.UTF16BE;
			return BOMType.None;
		}

		private static bool HasUTF8Sequence(byte[] bytes) {
			for (int i = 0; i < bytes.Length; i++) {
				int extra = bytes.Length - i - 1;
				bool IsContinuation(int offset) => (bytes[i + offset] & 0b11000000) == 0b10000000;
				if ((bytes[i] & 0b11100000) == 0b11000000 && extra >= 1 && IsContinuation(1) &&
					(bytes[i] & 0b00011110) != 0)
					return true;
				if ((bytes[i] & 0b11110000) == 0b11100000 && extra >= 2 && IsContinuation(1) && IsContinuation(2) &&
					(bytes[i] & 0b00001111 | bytes[i + 1] & 0b00100000) != 0)
					return true;
				if ((bytes[i] & 0b11111000) == 0b11110000 && extra >= 3 && IsContinuation(1) && IsContinuation(2) && IsContinuation(3) &&
					(bytes[i] & 0b00000111 | bytes[i + 1] & 0b00110000) != 0)
					return true;
				if ((bytes[i] & 0b11111100) == 0b11111000 && extra >= 4 && IsContinuation(1) && IsContinuation(2) && IsContinuation(3) && IsContinuation(4) &&
					(bytes[i] & 0b00000011 | bytes[i + 1] & 0b00111000) != 0)
					return true;
				if ((bytes[i] & 0b11111110) == 0b11111100 && extra >= 5 && IsContinuation(1) && IsContinuation(2) && IsContinuation(3) && IsContinuation(4) && IsContinuation(5) &&
					(bytes[i] & 0b00000001 | bytes[i + 1] & 0b00111100) != 0)
					return true;
			}
			return false;
		}

		private class LineInfo {
			public int LeadingWhitespaceCount;
			public bool EndsWithComment;
			public bool EndsWithXmlDocComment;
			public bool IsPreprocessorDirective;
			public bool EndsWithOpenBrace;
			public bool EndsWithCloseBrace;
			public bool EndsWithSemicolon;
			public bool EndsWithComma;
			public bool IsEmpty;
			public bool IsEmptyAfterEndingWithOpenBrace;
		}

		private abstract class Context {
			public int BlockDepth { get; set; }
			public int ParenDepth { get; set; }
		}

		private class NormalContext : Context { }

		private class InterpolatedStringContext : Context { }

		private class VerbatimInterpolatedStringContext : Context { }

		private enum BOMType {
			None = 0,
			UTF8 = 1,
			UTF16LE = 2,
			UTF16BE = 3
		}
	}
}
